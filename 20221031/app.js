// 비트코인 백서

// 비트코인은 개인 대 개인 전자 화폐 시스템
// P2P란 , Peer to Peer로서 인터넷에서 개인과 개인이 직접 연결되어 파일을 공유하는 것을 이야기함
// 개인과 개인간에서 전자 화폐 송금 시스템을 제안한다.
// Satoshi Nakamoto(사토시 나카모토) 누구인지 밝혀지지 않음
// 개발자이기 전에 경제학으로도 지식을 가지고 있었을 것으로 추측됨

// 개인 대 개인 버전 전자 화폐는 금융기관을 거치지 않고
// 한 쪽에서 다른 쪽으로 직접 전달되는 온라인 결제를 실현한다.
// 우리가 사용하고있는 금융시스템은 금융기관을 통해서만 한쪽에서 다른쪽으로 직접 전달되는 온라인 지불
// 오프라인에서는 직접 우리가 현금을 지불하면 다른사람한테 직접 전달이 가능한데
// 온라인 같은 경우는 개인과 개인간에서 구축된 시스템을 거치지 않는 이상 존재하지 않음
// 비트코인은 어떤 중앙 기관없이 내가 가진 자산을 다른 사람에게 전달 할 수 있는 시스템을 구현

// 무슨 문제점이? 온라인 전자 서명 시스템은 적용되어있고
// 이중지불을 막기 위해 신뢰 할 수 있는 제3자 필요
// 이중 지불 문제 해결의 솔루션을 제안

// 전자 서명만 사용 할 때는 이중지불을 막을수가 없기 때문에 우리는 일반적으로 중앙화된 기관이 필요
// 중앙화된 기관 없이 이중 지불 문제 해결의 솔루션을 제안하는것

// 이중 지불을 막기위해서 거래 내용을 해싱하고 타임스템프를 찍어서 해시 기반 작업 증명을
// 연결한 사슬로 만들고 작업 증명을 재수행하지 않으면 변경 할 수 없는 기록을 만듦

// 일반적으로 우리가 알고 있는 블록체인이란 단어가 여기서 나온다.
// 연결한 사슬이라는 것이 블록들을 체인 형태로 연결한 형태를 타임스탬프를 찍어서 기록한 것
// 블록 체인이라는 데이터들을 안전하게 위변조가 되지 않게 해시 기반 작업 증명을 통해서
// 블록체인이 안전하게 보관이 되고 생성이 되었다는것을 증명 할 수 있는 기반이 된 것

// 가장 긴 사슬 : 개인 대 개인간의 네트워크이고 중앙 기관이 없다 보니까 체인이 여러개로 나누어지기 때문에 가장 긴 체인을 선택함
// 이게 "Longest Chain Rule"(롱기스트 체인 룰)과 연관이 있음
// 롱기스트 체인 룰을 통해서 중앙화된 기관 없이 항상 하나의 체인을 유지 할 수 있는 기반을 만듦

// 2008년 비트코인이 처음 출시 됬을때 사토시 나카모토가 생각했던 내용은 개인대 개인 네트워크에
// 참여하는 사용자들은 일반적으로 집에서 PC를 사용해서 네트워크에 참여할거라고 생각했고
// 네트워크에 참여하는 사람들이 작업 증명을 사용할때는 자신의 PC의 CPU를 통해서 작업을
// 진행하기 때문에 CPU 파워풀이라고 이야기 했지만
// 실제로 비트코인 네트워크가 역사적으로
// 발전하면서 채굴풀이라는 개념도 등장하고 전문 채굴기들도 등장하면서
// 전문 채굴기들이 사용할 공통 용어가 필요해졌고
// 지금은 CPU 파워가 아니라 해시레이트라고 부름

// 사토시 나카모토는 2008년 금융위기를 보며 현재 우리가 신뢰하는 중앙 기관이 실제로는
// 신뢰하기 어려운 기관이라 생각했고 비트코인을 제안하게 되었다.

// 왜 비트코인을 처음 알아야 할까
// 비트코인이 블록체인에서 가지고 있어야할 철학적 경제적 기술적 특성을 모두 잘 포함하고 있기 때문에
// 블록체인에서 가장 중요한 철학 탈중앙화 Decentralize(디센트럴 라이즈)
// 블록체인의 모든 기술 개발은 항상 중앙화된 기관을 없애려고 노력하는 형태
// 실제로 코어를 개발하고 운용하는 사람들은 중앙화된 거래소나 중앙화된 서비스들을
// 어떻게 하면 탈중앙화 할까 노력하고 기관들 없이 거래 할 수 있는 방안들의 개발을 진행하고 있음

// 블록 체인의 4대 요소 기술
// 1. 블록과 트랜잭션 : 트랜잭션은 사용자의 송금내역이고 송금내역들을 하나의
//                     블록에 포함시켜야지만 안정성을 보장 할 수 있는 기반을 만들수 있다.
//                     그 블록들이 해시 알고리즘과 POW를 통해서 연결하는 형태가 블록 체인
// 2. 분산 네트워크 : 사용자들이 언제든지 네트워크에 참여 할 수 있고 나갈 수 있는 것이
//                   분산 네트워크
// 3. 암호화 : 본인 증명뿐만 아니라 거래가 위변조 되지 않았다고 증명 할 수 있음
// 4. 합의 알고리즘 : 분산 네트워크에서 중앙화된 기관이 없으니까 하나의 체인을 구성하는 것이 매우
//                   중요하고 그리고 모든 분산화된 네트워크에서 모든 사용자들이 납득 할 수 있는
//                   하나의 거래내역이 필요한데 이걸 하나로 정리해주는 것이 합의 알고리즘
//                   합의 알고리즘은 일반적으로 POW만 부르는데 POW와 롱기스트 체인 룰을 포함해야지
//                   실제로 네트워크 기준으로 하나의 체인 유지를 할 수 있음

// POW (Proof of Work) : 스팸메일을 방지하고자 고안된 작업증명
//                       이메일을 보내기 위해 작업증명 알고리즘을 이용해서 해시값을 찾은것

// 블록의 구성
// 블록은 특정 정보들을 담아놓은 객체

// 블록은 영역 Header, Body로 나눠져있고 구분하기 위해서

// Header
// 1. 버전 정보
// 2. 이전 블록의 해시
// 3. 몇번째 블록인지의 정보(높이)
// 4. 블록의 생성 시간의 정보(타임 스탬프)
// 5. 블록의 해시
// 6. Body의 내용을 해싱한 값(머클 루트)
// 7. 채굴의 난이도
// 8. 논스

// Body
// 1. 블록에 저장할 데이터

// 블록에 대한 이해를 좀 쉽게 하기위해서 Header, Body라고 구분했을뿐
// 실제 구성은 헤더 영역과 바디 영역을 구분지어서 블록 생성 하진 않는다.

// 자바 스크립트 객체로 만들어 보자

const Block = {
  version: "1.0.0", // 블록의 버전 소프트웨어/프로토 버전
  previousHash: "", // 이전 블록의 해시
  height: 0, // 블록 체인에 연결된 블록의 수 블록이 생성된 순서는 높이로 표현한다.
  timestamp: 15648434541, // 블록 생성 시간
  hash: "", // 해시 특정 블록을 식별할때 고유 식별자로 해시값을 사용한다.
  // 해시값은 블록의 생성일, 버전, 비츠, 머클루트, 이전 블록의 해시, 논스라 불리는
  // 임시값 등등 조합해서 해시로 변환해서 생성
  merkleRoot: "", // block body의 내용을 해싱한 값 2진 트리 형태
  // 머클루트는 블록의 트랜젝션에 대한 내용이 저장되어 있고. 트랜잭션의 내용들을
  // 해싱해서 해시값으로 만튼 트리구조가 머클 트리라고 한다.
  // 머클트리의 루트에 대한 해시값이 머클루트
  bits: "", // 비츠 난이도 조절용 수치 --- 질문
  difficulty: "", // 채굴의 난이도
  nonce: "", // 논스는 최초에 0에서부터 시작해서 조건이 만족하는 해쉬값을 찾을때 까지 1씩
  // 증가하는 계산 횟수
  data: ["fsdfsdfs"], // block body 내용 트랜젝션의 내용이 블록안에 데이터로 저장된다.
};

// 블록체인의 거래정보 변경이 불가능한 이유

// 거래 정보의 해시값은 거래가 포함된 블록의 머클루트 계산에 입력값으로 사용되고
// 머클루트는 블록 해시의 계산 입력값으로 사용된다.
// A블록이랑 B블록이 있다고하고
// A블록의 해시는 다음 B블록의 previousHash(이전 블록의 해시) 값에 저장되고
// previousHash는 A블록의 헤더 정보이고 블록 해시를 계산하기위한 값으로 사용된다.
// 그렇기 때문에 거래정보가 변경되면 머클루트가 변경되고 머클루트가 변경이 되면
// 블록 해시가 변경되어서 블록 해시의 변경은 다음 블록 해시 변경으로 연쇄적으로 이어지게 된다.

// 거래 정보 변경 -> 머클루트 변경 -> 머클루트 변경으로 블록해시 변경 -> 블록해시는 논스값을 찾아서
// 작업 증명이 되야 구할수 있기 때문에 거래정보를 변경한 블록부터 그 이후의 모든 블록을 순서대로
// 다시 채굴해야한다.

// 완료된 거래 정보를 변경하려면 변경하려는 거래 정보가 있는 블록부터 그 이후의 모든 블록을
// 순서대로 다시 채굴해야 하기 때문에 시간이 무척 많이 걸리고 그동안 다른 노드들에 의해서
// 블록이 계속 추가되어 완료된 거래 정보의 변경은 현실적으로 불가능하다.

// 작업 증명 POW(proof of Work)
// 새로운 블록을 블록체인에 추가하는 작업을 완료한것을 증명하는 것
// 새 블록을 블록체인에 추가하려면 블록의 블록 해시를 계산해야하고
// 블록 해시의 계산은 블록 해더 정보의 논스 값을 계산해서 구한다.
// 논스 값을 구하는게 작업증명이다.

// 자바스크립트로 만들자

// 블록의 해시값과 머클루트값을 Crypto-js와 merkle 라이브러리를 쓸거고
// 블록의 해시값과 머클루트 값이 어떻게 생성되는지 한번 구조를 보자

// 설치 명령어
// ----------------------------------------------
// npm i crypto-js merkle
// ----------------------------------------------
